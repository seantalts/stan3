use std::str::FromStr;
use ast::Expr::*;
use ast::Expr;
use stan_to_math::maybe_translate;

grammar;

Tier<Op, NextTier>: Box<Expr> = {
    <l: Tier<Op, NextTier>> <f:Op> <r:NextTier>
        => Box::new(FnApp(f, vec![l, r])),
    NextTier
}

CommaList<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e { // (1)
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Expr = Tier<tier2op, Factor>;
pub Factor = Tier<tier1op, Term>;
pub Exprs = CommaList<Expr>;

pub Term: Box<Expr> = {
    int => Box::new(Int(<>)),
    float => Box::new(Real(<>)),
    "(" <Expr> ")",
    ident => Box::new(Var(<>)),
    <f:ident> "(" <args:Exprs> ")" => Box::new(FnApp(maybe_translate(f), args))
};

tier1op: String = r"[\*/]" => String::from(<>);
tier2op: String = r"[\+\-]" => String::from(<>);
//prefix_op: String = r"[-]" => String::from(<>);
int: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();
float: String = r"[0-9]+\.[0-9]+" => String::from(<>);
ident: String = r"[a-zA-Z][a-zA-Z0-9_]*" => String::from(<>);
comma: () = ",";


// <p:A> <q:B> => Foo {<>} is equivalent to	<p:A> <q:B> => Foo {p:p, q:q}
