use std::str::FromStr;
use ast::{Expr, Expr::*, Statement, Statement::*};
use stan_to_math::maybe_translate;

grammar;

Tier<Op, NextTier>: Expr = {
    <l: Tier<Op, NextTier>> <f:Op> <r:NextTier>
        => FnApp(f, vec![l, r]),
    NextTier
}

CommaList<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

SemicolonList<T>: Vec<T> = {
    <v:(<T> ";")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Expr = Tier<tier2op, Factor>;
pub Factor = Tier<tier1op, Term>;
pub Exprs = CommaList<Expr>;

pub Term: Expr = {
    int => Int(<>),
    float => Real(<>),
    "(" <Expr> ")",
    ident => Var(<>),
    <f:ident> "(" <args:Exprs> ")" => FnApp(maybe_translate(f), args)
};

pub Statement: Statement = {
    <f:ident> "=" <expr:Expr> => Assign(f, expr),
    <e: Expr> => Expr(e),
}

pub Statements = SemicolonList<Statement>;

tier1op: String = r"[\*/]" => String::from(<>);
tier2op: String = r"[\+\-]" => String::from(<>);
//prefix_op: String = r"[-]" => String::from(<>);
int: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();
float: String = r"[0-9]+\.[0-9]+" => String::from(<>);
ident: String = r"[a-zA-Z][a-zA-Z0-9_]*" => String::from(<>);
comma: () = ",";


// <p:A> <q:B> => Foo {<>} is equivalent to	<p:A> <q:B> => Foo {p:p, q:q}
